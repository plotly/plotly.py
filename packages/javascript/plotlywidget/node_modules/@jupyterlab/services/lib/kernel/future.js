"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var coreutils_1 = require("@phosphor/coreutils");
var disposable_1 = require("@phosphor/disposable");
var messages_1 = require("./messages");
/**
 * Implementation of a kernel future.
 */
var KernelFutureHandler = /** @class */ (function (_super) {
    __extends(KernelFutureHandler, _super);
    /**
     * Construct a new KernelFutureHandler.
     */
    function KernelFutureHandler(cb, msg, expectShell, disposeOnDone, kernel) {
        var _this = _super.call(this, cb) || this;
        _this._status = 0;
        _this._stdin = Private.noOp;
        _this._iopub = Private.noOp;
        _this._reply = Private.noOp;
        _this._done = new coreutils_1.PromiseDelegate();
        _this._hooks = new Private.HookList();
        _this._disposeOnDone = true;
        _this._msg = msg;
        if (!expectShell) {
            _this._setFlag(Private.KernelFutureFlag.GotReply);
        }
        _this._disposeOnDone = disposeOnDone;
        _this._kernel = kernel;
        return _this;
    }
    Object.defineProperty(KernelFutureHandler.prototype, "msg", {
        /**
         * Get the original outgoing message.
         */
        get: function () {
            return this._msg;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KernelFutureHandler.prototype, "done", {
        /**
         * A promise that resolves when the future is done.
         */
        get: function () {
            return this._done.promise;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KernelFutureHandler.prototype, "onReply", {
        /**
         * Get the reply handler.
         */
        get: function () {
            return this._reply;
        },
        /**
         * Set the reply handler.
         */
        set: function (cb) {
            this._reply = cb;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KernelFutureHandler.prototype, "onIOPub", {
        /**
         * Get the iopub handler.
         */
        get: function () {
            return this._iopub;
        },
        /**
         * Set the iopub handler.
         */
        set: function (cb) {
            this._iopub = cb;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KernelFutureHandler.prototype, "onStdin", {
        /**
         * Get the stdin handler.
         */
        get: function () {
            return this._stdin;
        },
        /**
         * Set the stdin handler.
         */
        set: function (cb) {
            this._stdin = cb;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Register hook for IOPub messages.
     *
     * @param hook - The callback invoked for an IOPub message.
     *
     * #### Notes
     * The IOPub hook system allows you to preempt the handlers for IOPub messages handled
     * by the future. The most recently registered hook is run first.
     * If the hook returns false, any later hooks and the future's onIOPub handler will not run.
     * If a hook throws an error, the error is logged to the console and the next hook is run.
     * If a hook is registered during the hook processing, it won't run until the next message.
     * If a hook is removed during the hook processing, it will be deactivated immediately.
     */
    KernelFutureHandler.prototype.registerMessageHook = function (hook) {
        this._hooks.add(hook);
    };
    /**
     * Remove a hook for IOPub messages.
     *
     * @param hook - The hook to remove.
     *
     * #### Notes
     * If a hook is removed during the hook processing, it will be deactivated immediately.
     */
    KernelFutureHandler.prototype.removeMessageHook = function (hook) {
        if (this.isDisposed) {
            return;
        }
        this._hooks.remove(hook);
    };
    /**
     * Send an `input_reply` message.
     */
    KernelFutureHandler.prototype.sendInputReply = function (content) {
        this._kernel.sendInputReply(content);
    };
    /**
     * Dispose and unregister the future.
     */
    KernelFutureHandler.prototype.dispose = function () {
        this._stdin = Private.noOp;
        this._iopub = Private.noOp;
        this._reply = Private.noOp;
        if (!this._testFlag(Private.KernelFutureFlag.IsDone)) {
            this._done.reject(new Error('Canceled'));
        }
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle an incoming kernel message.
     */
    KernelFutureHandler.prototype.handleMsg = function (msg) {
        switch (msg.channel) {
            case 'shell':
                this._handleReply(msg);
                break;
            case 'stdin':
                this._handleStdin(msg);
                break;
            case 'iopub':
                this._handleIOPub(msg);
                break;
            default:
                break;
        }
    };
    KernelFutureHandler.prototype._handleReply = function (msg) {
        var reply = this._reply;
        if (reply) {
            reply(msg);
        }
        this._replyMsg = msg;
        this._setFlag(Private.KernelFutureFlag.GotReply);
        if (this._testFlag(Private.KernelFutureFlag.GotIdle)) {
            this._handleDone();
        }
    };
    KernelFutureHandler.prototype._handleStdin = function (msg) {
        var stdin = this._stdin;
        if (stdin) {
            stdin(msg);
        }
    };
    KernelFutureHandler.prototype._handleIOPub = function (msg) {
        var process = this._hooks.process(msg);
        var iopub = this._iopub;
        if (process && iopub) {
            iopub(msg);
        }
        if (messages_1.KernelMessage.isStatusMsg(msg) &&
            msg.content.execution_state === 'idle') {
            this._setFlag(Private.KernelFutureFlag.GotIdle);
            if (this._testFlag(Private.KernelFutureFlag.GotReply)) {
                this._handleDone();
            }
        }
    };
    KernelFutureHandler.prototype._handleDone = function () {
        if (this._testFlag(Private.KernelFutureFlag.IsDone)) {
            return;
        }
        this._setFlag(Private.KernelFutureFlag.IsDone);
        this._done.resolve(this._replyMsg);
        if (this._disposeOnDone) {
            this.dispose();
        }
    };
    /**
     * Test whether the given future flag is set.
     */
    KernelFutureHandler.prototype._testFlag = function (flag) {
        // tslint:disable-next-line
        return (this._status & flag) !== 0;
    };
    /**
     * Set the given future flag.
     */
    KernelFutureHandler.prototype._setFlag = function (flag) {
        // tslint:disable-next-line
        this._status |= flag;
    };
    return KernelFutureHandler;
}(disposable_1.DisposableDelegate));
exports.KernelFutureHandler = KernelFutureHandler;
var Private;
(function (Private) {
    /**
     * A no-op function.
     */
    Private.noOp = function () { };
    /**
     * A polyfill for a function to run code outside of the current execution context.
     */
    var defer = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : setImmediate;
    var HookList = /** @class */ (function () {
        function HookList() {
            this._hooks = [];
        }
        /**
         * Register a hook.
         *
         * @param hook - The callback to register.
         */
        HookList.prototype.add = function (hook) {
            this.remove(hook);
            this._hooks.push(hook);
        };
        /**
         * Remove a hook.
         *
         * @param hook - The callback to remove.
         */
        HookList.prototype.remove = function (hook) {
            var index = this._hooks.indexOf(hook);
            if (index >= 0) {
                this._hooks[index] = null;
                this._scheduleCompact();
            }
        };
        /**
         * Process a message through the hooks.
         *
         * #### Notes
         * The most recently registered hook is run first.
         * If the hook returns false, any later hooks will not run.
         * If a hook throws an error, the error is logged to the console and the next hook is run.
         * If a hook is registered during the hook processing, it won't run until the next message.
         * If a hook is removed during the hook processing, it will be deactivated immediately.
         */
        HookList.prototype.process = function (msg) {
            var continueHandling;
            // most recently-added hook is called first
            for (var i = this._hooks.length - 1; i >= 0; i--) {
                var hook = this._hooks[i];
                if (hook === null) {
                    continue;
                }
                try {
                    continueHandling = hook(msg);
                }
                catch (err) {
                    continueHandling = true;
                    console.error(err);
                }
                if (continueHandling === false) {
                    return false;
                }
            }
            return true;
        };
        /**
         * Schedule a cleanup of the list, removing any hooks that have been nulled out.
         */
        HookList.prototype._scheduleCompact = function () {
            var _this = this;
            if (!this._cleanupScheduled) {
                this._cleanupScheduled = true;
                defer(function () {
                    _this._cleanupScheduled = false;
                    _this._compact();
                });
            }
        };
        /**
         * Compact the list, removing any nulls.
         */
        HookList.prototype._compact = function () {
            var numNulls = 0;
            for (var i = 0, len = this._hooks.length; i < len; i++) {
                var hook = this._hooks[i];
                if (this._hooks[i] === null) {
                    numNulls++;
                }
                else {
                    this._hooks[i - numNulls] = hook;
                }
            }
            this._hooks.length -= numNulls;
        };
        return HookList;
    }());
    Private.HookList = HookList;
    /**
     * Bit flags for the kernel future state.
     */
    var KernelFutureFlag;
    (function (KernelFutureFlag) {
        KernelFutureFlag[KernelFutureFlag["GotReply"] = 1] = "GotReply";
        KernelFutureFlag[KernelFutureFlag["GotIdle"] = 2] = "GotIdle";
        KernelFutureFlag[KernelFutureFlag["IsDone"] = 4] = "IsDone";
        KernelFutureFlag[KernelFutureFlag["DisposeOnDone"] = 8] = "DisposeOnDone";
    })(KernelFutureFlag = Private.KernelFutureFlag || (Private.KernelFutureFlag = {}));
})(Private || (Private = {}));
