"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
Object.defineProperty(exports, "__esModule", { value: true });
var coreutils_1 = require("@phosphor/coreutils");
var minimist = require("minimist");
var url_1 = require("./url");
/**
 * The namespace for Page Config functions.
 */
var PageConfig;
(function (PageConfig) {
    /**
     * Get global configuration data for the Jupyter application.
     *
     * @param name - The name of the configuration option.
     *
     * @returns The config value or an empty string if not found.
     *
     * #### Notes
     * All values are treated as strings.
     * For browser based applications, it is assumed that the page HTML
     * includes a script tag with the id `jupyter-config-data` containing the
     * configuration as valid JSON.  In order to support the classic Notebook,
     * we fall back on checking for `body` data of the given `name`.
     *
     * For node applications, it is assumed that the process was launched
     * with a `--jupyter-config-data` option pointing to a JSON settings
     * file.
     */
    function getOption(name) {
        if (configData) {
            return configData[name] || Private.getBodyData(name);
        }
        configData = Object.create(null);
        var found = false;
        // Use script tag if available.
        if (typeof document !== 'undefined') {
            var el = document.getElementById('jupyter-config-data');
            if (el) {
                configData = JSON.parse(el.textContent || '');
                found = true;
            }
        }
        // Otherwise use CLI if given.
        if (!found && typeof process !== 'undefined') {
            try {
                var cli = minimist(process.argv.slice(2));
                if ('jupyter-config-data' in cli) {
                    var path = require('path');
                    var fullPath = path.resolve(cli['jupyter-config-data']);
                    /* tslint:disable */
                    // Force Webpack to ignore this require.
                    configData = eval('require')(fullPath);
                    /* tslint:enable */
                }
            }
            catch (e) {
                console.error(e);
            }
        }
        if (!coreutils_1.JSONExt.isObject(configData)) {
            configData = Object.create(null);
        }
        else {
            for (var key in configData) {
                // Quote characters are escaped, unescape them.
                configData[key] = String(configData[key]).split('&#39;').join('"');
            }
        }
        return configData[name] || '';
    }
    PageConfig.getOption = getOption;
    /**
     * Set global configuration data for the Jupyter application.
     *
     * @param name - The name of the configuration option.
     * @param value - The value to set the option to.
     *
     * @returns The last config value or an empty string if it doesn't exist.
     */
    function setOption(name, value) {
        var last = getOption(name);
        configData[name] = value;
        return last;
    }
    PageConfig.setOption = setOption;
    /**
     * Get the base url for a Jupyter application.
     */
    function getBaseUrl() {
        var baseUrl = getOption('baseUrl');
        if (!baseUrl || baseUrl === '/') {
            baseUrl = (typeof location === 'undefined' ?
                'http://localhost:8888/' : location.origin + '/');
        }
        return url_1.URLExt.parse(baseUrl).toString();
    }
    PageConfig.getBaseUrl = getBaseUrl;
    /**
     * Get the tree url for a JupyterLab application.
     */
    function getTreeUrl() {
        return url_1.URLExt.join(getBaseUrl(), getOption('pageUrl'), 'tree');
    }
    PageConfig.getTreeUrl = getTreeUrl;
    /**
     * Get the base websocket url for a Jupyter application.
     */
    function getWsUrl(baseUrl) {
        var wsUrl = getOption('wsUrl');
        if (!wsUrl) {
            baseUrl = baseUrl || getBaseUrl();
            if (baseUrl.indexOf('http') !== 0) {
                if (typeof location !== 'undefined') {
                    baseUrl = url_1.URLExt.join(location.origin, baseUrl);
                }
                else {
                    baseUrl = url_1.URLExt.join('http://localhost:8888/', baseUrl);
                }
            }
            wsUrl = 'ws' + baseUrl.slice(4);
        }
        return url_1.URLExt.parse(wsUrl).toString();
    }
    PageConfig.getWsUrl = getWsUrl;
    /**
     * Get the authorization token for a Jupyter application.
     */
    function getToken() {
        return getOption('token') || Private.getBodyData('jupyterApiToken');
    }
    PageConfig.getToken = getToken;
    /**
     * Private page config data for the Jupyter application.
     */
    var configData = null;
})(PageConfig = exports.PageConfig || (exports.PageConfig = {}));
/**
 * A namespace for module private data.
 */
var Private;
(function (Private) {
    /**
     * Get a url-encoded item from `body.data` and decode it
     * We should never have any encoded URLs anywhere else in code
     * until we are building an actual request.
     */
    function getBodyData(key) {
        if (typeof document === 'undefined' || !document.body) {
            return '';
        }
        var val = document.body.dataset[key];
        if (typeof val === 'undefined') {
            return '';
        }
        return decodeURIComponent(val);
    }
    Private.getBodyData = getBodyData;
})(Private || (Private = {}));
